<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-08T18:19:56+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">TheRouter - 移动端模块化解决方案</title><subtitle>TheRouter 是一个 Kotlin 编写，用于 Android 模块化开发的一整套解决方案框架。</subtitle><entry><title type="html">TheRouterSwift iOS 路由介绍</title><link href="http://localhost:4000/docs/2023/09/26/01" rel="alternate" type="text/html" title="TheRouterSwift iOS 路由介绍" /><published>2023-09-26T00:00:00+08:00</published><updated>2023-09-26T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/09/26/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/09/26/01">&lt;h2&gt;背景&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;随着社区对支持Swift的需求日益增多，Swift5.0二进制库也具有更好的稳定性和兼容性表现，货拉拉技术团队根据社区反馈及内部讨论，决定开源内部业务使用的Swift版本路由组件，与2023年8月份已发布的Objective-C版本路由组件组成一个完整解决方案。&lt;/li&gt;
&lt;li&gt;TheRouter开源团队将把重心放在维护和升级Swift版本的TheRouter上。同时也会持续支持Objective-C版本的易用性，并欢迎社区贡献。&lt;/li&gt;
&lt;li&gt;对于使用Objective-C版本TheRouter的用户，建议将版本固定为1.0.0版以确保稳定性。
## Features
TheRouter一个用于模块间解耦和通信，基于Swift协议进行动态懒加载注册路由与打开路由的工具。同时支持通过Service-Protocol寻找对应的模块，并用 protocol进行依赖注入和模块通信。

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1. 页面导航跳转能力&lt;/strong&gt;：支持常规vc或Storyboard的push/present/popToTaget/windowNavRoot/modalDismissBeforePush跳转能力；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2. 路由自动注册能力&lt;/strong&gt;：懒加载方式动态注册路由，仅当第一次调用OpenURL时进行动态注册；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3. 路由映射文件导出&lt;/strong&gt;：支持将工程中的路由映射关系导出为文档，支持JSON、Plist格式，方便开发者进行双端的汇总比对、记录等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4. 服务自动注册能力&lt;/strong&gt;：动态注册服务，使用runtime方式自动注入；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5. 硬编码消除&lt;/strong&gt;：将注册的path转为静态字符串常量供业务使用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;6. 动态化能力&lt;/strong&gt;：支持添加重定向，移除重定向、动态添加路由、动态移除路由、拦截器、错误path修复等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;7. 链式编程&lt;/strong&gt;：支持链式编程方式拼接URL与参数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;8. 适配Objective-C&lt;/strong&gt;：OC类可以在Swift中使用继承的方式遵循协议来进行动态注册；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;9. 服务调用&lt;/strong&gt;：支持本地服务调用与远端服务调用；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://z1.ax1x.com/2023/09/26/pPHS4UO.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;随着项目需求的日益增加，开发人员的不断增加，带来了很多问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模块划分不清晰，任何开发人员随意调用并修改其他模块的代码实现以满足自己的业务需求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;维护困难，同一组件的不同服务，散落在工程各个地方，不利于统一维护修改替换。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;模块负责人无法清晰，导致同一功能多人维护，造成冲突。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外件拆分完之后都上升到远端，那么它们之间本地的代码是没办法相互依赖的，所以就需要通过一种工具，然后去实现透传服务的能力。我们需要一个中间件去处理这些问题。路由即是将耦合进行转移，通过增加中间层映射关系，解决业务之间的依赖关系。&lt;/p&gt;

&lt;h2&gt;一个成熟的路由该是什么样子&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;  业务组件化之后，组件化需要将整个项目的各个模块进行解耦，升级远端之后，界面之间的跳转怎么解决？&lt;strong&gt;路由 Api&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt;  动态注册路由，无需手动注册。服务的动态注册，无需手动注册。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt;  端上跳转统一问题怎么解决？&lt;strong&gt;使用统一 URL 映射方式处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt;  业务跳转中出现问题，如何修改跳转逻辑？服务如何降级? &lt;strong&gt;远端下发配置，修改跳转 URL&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt;  业务服务异常，界面改为 h5 界面。&lt;strong&gt;重定向&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt;  App 跳转出现问题如何跳转到同一个本地的 error 界面？&lt;strong&gt;统一失败处理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;/strong&gt;  如何在跳转前增加强制的业务逻辑处理，比如业务调整，必须先执行某些操作，才能进入。&lt;strong&gt;重定向&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;/strong&gt;  业务中有很多需要前置跳转，比如先登录才能去订单列表，如何实现。&lt;strong&gt;拦截器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.&lt;/strong&gt;  如何测试各个跳转业务是否正常。 &lt;strong&gt;路由 Path 校验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.&lt;/strong&gt; 如何把最频繁的业务跳转前置，减少查询次数？&lt;strong&gt;增加优先级 priority&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.&lt;/strong&gt; 本地服务通过路由调用，远端服务通过路由调用 &lt;strong&gt;支持服务调用&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;整体设计思路&lt;/h2&gt;

&lt;p&gt;为了和Android端保持一致，使用了URL，class注册的方式实现。通过URL匹配方式查询数组中保存的模版信息，找到执行获取对应实例，执行跳转操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://z1.ax1x.com/2023/09/26/pP7zc0f.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;使用介绍预览&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/image/therouter_ios1.gif&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;如何集成使用&lt;/h2&gt;

&lt;h3&gt;CocoaPods&lt;/h3&gt;

&lt;p&gt;Add the following entry in your Podfile:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;   pod 'TheRouter', '1.1.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Swift限制版本&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt; Swift5.0 or above
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TheRouter 使用方式&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt; ### 注册&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;鉴于已经实现了自动注册能力，开发者无需自己添加路由，只需要进行如下操作即可&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;/// 实现TheRouterable协议
extension TheRouterController: TheRouterable {

    static var patternString: [String] {
        [&quot;scheme://router/demo&quot;]
    }

    static func registerAction(info: [String : Any]) -&amp;gt; Any {
        debugPrint(info)

        let vc =  TheRouterController()
        vc.qrResultCallBack = info[&quot;clouse&quot;] as? QrScanResultCallBack
        vc.resultLabel.text = info.description
        return vc
    }
}

/// 在AppDelegate中实现懒加载的闭包
// 路由懒加载注册
TheRouter.lazyRegisterRouterHandle { url, userInfo in
    TheRouterManager.injectRouterServiceConfig(webRouterUrl, serivceHost)
    return TheRouterManager.addGloableRouter([&quot;.The&quot;], url, userInfo)
}

// 动态注册服务
TheRouterManager.registerServices()

// 日志回调，可以监控线上路由运行情况
TheRouter.logcat { url, logType, errorMsg in
    debugPrint(&quot;TheRouter: logMsg- \(url) \(logType.rawValue) \(errorMsg)&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;OC 注解的形式&lt;/h4&gt;

&lt;p&gt;这里列举了OC使用注解的方式，Swift因为其缺乏动态性，是不支持注解的。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;//使用注解
@page(@&quot;home/main&quot;)
- (UIViewController *)homePage{
    // Do stuff...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Swift 注册形式&lt;/h4&gt;

&lt;p&gt;Swift 中，我们都知道 Swift 是不支持注解的，那么 Swift 动态注册路由该怎么解决呢，我们使用 runtime 遍历工程里的方式找到遵循了路由协议的类进行自动注册。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;public class func registerRouterMap(_ registerClassPrifxArray: [String], _ urlPath: String, _ userInfo: [String: Any]) -&amp;gt; Any? {

        let expectedClassCount = objc_getClassList(nil, 0)
        let allClasses = UnsafeMutablePointer&amp;lt;AnyClass&amp;gt;.allocate(capacity: Int(expectedClassCount))
        let autoreleasingAllClasses = AutoreleasingUnsafeMutablePointer&amp;lt;AnyClass&amp;gt;(allClasses)
        let actualClassCount: Int32 = objc_getClassList(autoreleasingAllClasses, expectedClassCount)

        var resultXLClass = [AnyClass]()
        for i in 0 ..&amp;lt; actualClassCount {

            let currentClass: AnyClass = allClasses[Int(i)]
            let fullClassName: String = NSStringFromClass(currentClass.self)

            for value in registerClassPrifxArray {
                if (fullClassName.containsSubString(substring: value))  {
                    if currentClass is UIViewController.Type {
                        resultXLClass.append(currentClass)
                    }

    #if DEBUG
                    if let clss = currentClass as? CustomRouterInfo.Type {
                        assert(clss.patternString.hasPrefix(&quot;scheme://&quot;), &quot;URL非scheme://开头，请重新确认&quot;)
                        apiArray.append(clss.patternString)
                        classMapArray.append(clss.routerClass)
                    }
    #endif
                }
            }
        }

        for i in 0 ..&amp;lt; resultXLClass.count {
            let currentClass: AnyClass = resultXLClass[i]
            if let cls = currentClass as? TheRouterable.Type {
                let fullName: String = NSStringFromClass(currentClass.self)

                for s in 0 ..&amp;lt; cls.patternString.count {

                    if fullName.hasPrefix(NSKVONotifyingPrefix) {
                        let range = fullName.index(fullName.startIndex, offsetBy: NSKVONotifyingPrefix.count)..&amp;lt;fullName.endIndex
                        let subString = fullName[range]
                        pagePathMap[cls.patternString[s]] = &quot;\(subString)&quot;
                        TheRouter.addRouterItem(cls.patternString[s], classString: &quot;\(subString)&quot;)
                    } else {
                        pagePathMap[cls.patternString[s]] = fullName
                        TheRouter.addRouterItem(cls.patternString[s], classString: fullName)
                    }
                }
            }
        }

#if DEBUG
        debugPrint(pagePathMap)
        routerForceRecheck()
#endif
        TheRouter.routerLoadStatus(true)
        return TheRouter.openURL(urlPath, userInfo: userInfo)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了避免无效遍历，我们通过传入 registerClassPrifxArray 指定我们遍历包含这些前缀的类即可。一旦是 UIViewController.Type 类型就进行存储，然后再进行校验是否遵循 TheRouterable 协议，遵循则自动注册。无需手动注册。&lt;/p&gt;

&lt;h4&gt;路由注册的懒加载&lt;/h4&gt;

&lt;p&gt;采用动态注册有一个不好的情况就是在启动时就去动态注册，在 TheRouter 中注册的时机被延后了，放在了 App 第一次通过 TheRouter.openUrl()时进行注册，会判断路由是否加载完毕，未加载完毕进行加载，然后打开路由。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;@discardableResult
public class func openURL(_ urlString: String, userInfo: [String: Any] = [String: Any](), handler: complateHandler = nil) -&amp;gt; Any? {
    if urlString.isEmpty {
        return nil
    }
    if !shareInstance.isLoaded {
        return shareInstance.lazyRegisterHandleBlock?(urlString, userInfo)
    } else {
       return openCacheRouter((urlString, userInfo))
    }
}

// MARK: - Public method
@discardableResult
public class func openURL(_ uriTuple: (String, [String: Any]), handler: complateHandler = nil) -&amp;gt; Any? {
    if !shareInstance.isLoaded {
        return shareInstance.lazyRegisterHandleBlock?(uriTuple.0, uriTuple.1)
    } else {
        return openCacheRouter(uriTuple)
    }
}

public class func openCacheRouter(_ uriTuple: (String, [String: Any]), handler: complateHandler = nil) -&amp;gt; Any? {

    if uriTuple.0.isEmpty {
        return nil
    }

    if uriTuple.0.contains(shareInstance.serviceHost) {
        return routerService(uriTuple)
    } else {
        return routerJump(uriTuple)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;如何让 OC 类也享受到 Swift 路由&lt;/h4&gt;

&lt;p&gt;这是一个 OC 类的界面，实现路由的跳转需要继承 OC 类，并实现 TheRouterAble 协议即可&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;@interface TheRouterBController : UIViewController
@property (nonatomic, strong) UILabel *desLabel;
@end

@interface TheRouterBController ()

@end

@implementation TheRouterBController

- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor yellowColor];
    [self.view addSubview:self.desLabel];
    // Do any additional setup after loading the view.
}
@end

public class TheRouterControllerB: TheRouterBController, TheRouterable {

    public static var patternString: [String] {
        [&quot;scheme://router/demo2&quot;,
         &quot;scheme://router/demo2-Android&quot;]
    }

    public static var descriptions: String {
        &quot;TheRouterControllerDemo&quot;
    }

    public static func registerAction(info: [String : Any]) -&amp;gt; Any {
        let vc =  TheRouterBController()
        vc.desLabel.text = info.description
        return vc
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;同时支持手动单个注册&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;// 模型模式
TheRouter.addRouterItem(RouteItem(path: &quot;scheme://router/demo?&amp;amp;desc=简单注册,直接调用TheRouter.addRouterItem()注册即可&quot;, className: &quot;TheRouter_Example.TheRouterController&quot;, desc: &quot;简单注册,直接调用TheRouter&quot;, params: [&quot;key1&quot;: 1]))
// 字典模式
TheRouter.addRouterItem([&quot;scheme://router/demo?&amp;amp;desc=简单注册,直接调用TheRouter.addRouterItem()注册即可&quot;: &quot;TheRouter_Example.TheRouterController&quot;])
// 常量参数模式
TheRouter.addRouterItem(&quot;scheme://router/demo?&amp;amp;desc=简单注册&quot;, classString: &quot;TheRouter_Example.TheRouterController&quot;)
// 协议模式， TheRouterApi实现了 CustomRouterInfo协议
TheRouter.addRouterItem(TheRouterApi.patternString, classString: TheRouterApi.routerClass)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;同时支持手动批量注册&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;TheRouter.addRouterItem([&quot;scheme://router/demo&quot;: &quot;TheRouter_Example.TheRouterController&quot;,
                    &quot;scheme://router/demo1&quot;: &quot;TheRouter_Example.TheRouterControllerA&quot;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;移除&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;TheRouter.removeRouter(TheRouterViewCApi.patternString)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;打开&lt;/h3&gt;

&lt;p&gt;声明了不同的方法，主要用于明显的区分，内部统一调用 openURL&lt;/p&gt;

&lt;p&gt;便利构造器链式打开路由&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let model = TheRouterModel.init(name: &quot;AKyS&quot;, age: 18)
TheRouterBuilder.build(&quot;scheme://router/demo&quot;)
    .withInt(key: &quot;intValue&quot;, value: 2)
    .withString(key: &quot;stringValue&quot;, value: &quot;2222&quot;)
    .withFloat(key: &quot;floatValue&quot;, value: 3.1415)
    .withBool(key: &quot;boolValue&quot;, value: false)
    .withDouble(key: &quot;doubleValue&quot;, value: 2.0)
    .withAny(key: &quot;any&quot;, value: model)
    .navigation()

TheRouterBuilder.build(&quot;scheme://router/demo&quot;)
    .withInt(key: &quot;intValue&quot;, value: 2)
    .withString(key: &quot;stringValue&quot;, value: &quot;sdsd&quot;)
    .withFloat(key: &quot;floatValue&quot;, value: 3.1415)
    .withBool(key: &quot;boolValue&quot;, value: false)
    .withDouble(key: &quot;doubleValue&quot;, value: 2.0)
    .withAny(key: &quot;any&quot;, value: model)
    .navigation { params, instance in

    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开路由常用方式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;public class TheRouterApi: CustomRouterInfo {

    public static var patternString = &quot;scheme://router/demo&quot;
    public static var routerClass = &quot;TheRouter_Example.TheRouterController&quot;
    public var params: [String: Any] { return [:] }
    public var jumpType: LAJumpType = .push

    public init() {}
}

public class TheRouterAApi: CustomRouterInfo {

    public static var patternString = &quot;scheme://router/demo1&quot;
    public static var routerClass = &quot;TheRouter_Example.TheRouterControllerA&quot;
    public var params: [String: Any] { return [:] }
    public var jumpType: LAJumpType = .push

    public init() {}
}

TheRouter.openURL(TheRouterCApi.init().requiredURL)
TheRouter.openWebURL(&quot;https://xxxxxxxx&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;
@discardableResult
public class func openWebURL(_ uriTuple: (String, [String: Any])) -&amp;gt; Any? {
    return TheRouter.openURL(uriTuple)
}

@discardableResult
public class func openWebURL(_ urlString: String,
                             userInfo: [String: Any] = [String: Any]()) -&amp;gt; Any? {
    TheRouter.openURL((urlString, userInfo))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;元祖形式传入路由与追加参数&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;TheRouter.openURL((&quot;scheme://router/demo1?id=2&amp;amp;value=3&amp;amp;name=AKyS&amp;amp;desc=直接调用TheRouter.addRouterItem()注册即可，支持单个注册，批量注册，动态注册，懒加载动态注册&quot;, [&quot;descs&quot;: &quot;追加参数&quot;]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数传递方式&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let clouse = { (qrResult: String, qrStatus: Bool) in
    print(&quot;\(qrResult) \(qrStatus)&quot;)
    self.view.makeToast(&quot;\(qrResult) \(qrStatus)&quot;)
}
let model = TheRouterModel.init(name: &quot;AKyS&quot;, age: 18)
TheRouter.openURL((&quot;scheme://router/demo?id=2&amp;amp;value=3&amp;amp;name=AKyS&quot;, [&quot;model&quot;: model, &quot;clouse&quot;: clouse]))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;全局失败映射&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;TheRouter.globalOpenFailedHandler { info in
   debugPrint(info)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;拦截&lt;/h3&gt;

&lt;p&gt;比如在未登录情况下统一拦截：跳转消息列表之前先去登录，登录成功之后跳转到消息列表等。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let login = TheRouterLoginApi.templateString
 TheRouter.addRouterInterceptor([login], priority: 0) { (info) -&amp;gt; Bool in
       if LALoginManger.shared.isLogin {
             return true
       } else {
             TheRouter.openURL(TheRouterLoginApi().build)
             return false
       }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;登录成功之后删除拦截器即可。&lt;/p&gt;

&lt;h3&gt;路由 Path 与类正确安全校验&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;// MARK: - 客户端强制校验，是否匹配
public static func routerForceRecheck() {
    let patternArray = Set(pagePathMap.keys)
    let apiPathArray = Set(apiArray)
    let diffArray = patternArray.symmetricDifference(apiPathArray)
    debugPrint(&quot;URL差集：\(diffArray)&quot;)
    debugPrint(&quot;pagePathMap：\(pagePathMap)&quot;)
    assert(diffArray.count == 0, &quot;URL 拼写错误，请确认差集中的url是否匹配&quot;)

    let patternValueArray = Set(pagePathMap.values)
    let classPathArray = Set(classMapArray)
    let diffClassesArray = patternValueArray.symmetricDifference(classPathArray)
    debugPrint(&quot;classes差集：\(diffClassesArray)&quot;)
    assert(diffClassesArray.count == 0, &quot;classes 拼写错误，请确认差集中的class是否匹配&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;踩坑路由注册-KVO&lt;/h3&gt;

&lt;p&gt;在进行 classes 本地校验时遇到了类名不匹配问题。&lt;/p&gt;

&lt;p&gt;排查原因： 是因为为了避免路由在启动时就注册，影响启动速度，采用了懒加载的方式即第一次打开路由界面的时候才先进行注册然后跳转。但是在我们动态注册之前，某个类因为添加了 KVO (Key-Value Observing 键值监听)，这个类在遍历时 className 修改为了 NSKVONotifying_xxx。需要我们进行特殊处理，如下&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;/// 对于KVO监听，动态创建子类，需要特殊处理
public let NSKVONotifyingPrefix = &quot;NSKVONotifying_&quot;

if fullName.hasPrefix(NSKVONotifyingPrefix) {
    let range = fullName.index(fullName.startIndex, offsetBy: NSKVONotifyingPrefix.count)..&amp;lt;fullName.endIndex
    let subString = fullName[range]
    pagePathMap[cls.patternString[s]] = &quot;\(subString)&quot;
    TheRouter.addRouterItem(cls.patternString[s], classString: &quot;\(subString)&quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;动态调用路由&lt;/h2&gt;

&lt;p&gt;在之上的路由能力下，我们希望 App 能够支持动态增加路由，删除路由，重定向路由、通过路由调起本地服务、远端通过路由调起 App 服务能力，随即进行了动态化的扩展。&lt;/p&gt;

&lt;h3&gt;重定向功能&lt;/h3&gt;

&lt;p&gt;定义路由下发模型数据结构&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;public struct TheRouterInfo {
    public init() {}

    public var targetPath: String = &quot;&quot;
    public var orginPath: String = &quot;&quot;
    // 1: 表示替换或者修复客户端代码path错误 2: 新增路由path 3:删除路由
    public var routerType: TheRouterReloadMapEnum = .none 
    public var path: String = &quot;&quot; // 新的路由地址
    public var className: String = &quot;&quot; // 路由地址对应的界面
    public var params: [String: Any] = [:]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过远端下发重定向数据，原本跳转到白色界面的业务逻辑改为跳转到黄色界面&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let relocationMap = [&quot;routerType&quot;: 1, &quot;targetPath&quot;: &quot;scheme://router/demo1&quot;, &quot;orginPath&quot;: &quot;scheme://router/demo&quot;] as NSDictionary
TheRouterManager.addRelocationHandle(routerMapList: [relocationMap])
TheRouter.openURL(&quot;scheme://router/demo?desc=跳转白色界面被重定向到了黄色界面&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;重定向恢复&lt;/h3&gt;

&lt;p&gt;在业务中，通常会进行业务调整，那么重定向之后需要恢复的话，就需要移除重定向&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let relocationMap = [&quot;routerType&quot;: 4, &quot;targetPath&quot;: &quot;scheme://router/demo&quot;, &quot;orginPath&quot;: &quot;scheme://router/demo&quot;] as NSDictionary
TheRouterManager.addRelocationHandle(routerMapList: [relocationMap])
TheRouter.openURL(&quot;scheme://router/demo?desc=跳转白色界面被重定向到了黄色界面之后，根据下发数据又恢复到跳转白色界面&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;路由 Path 动态修复&lt;/h3&gt;

&lt;p&gt;在实际开发中，开发人员因为马虎写错了路由 Path，上线之后无法进行正常的业务跳转，此时就需要通过远端下发路由进行匹配跳转了。scheme://router/demo3 是正确 path,但是本地写错的路由 path 为 scheme://router/demo33，那么需要新增一个 path 进行映射。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let relocationMap = [&quot;routerType&quot;: 2, &quot;className&quot;: &quot;TheRouter_Example.TheRouterControllerC&quot;, &quot;path&quot;: &quot;scheme://router/demo33&quot;] as NSDictionary
TheRouterManager.addRelocationHandle(routerMapList: [relocationMap])
let value = TheRouterCApi.init().requiredURL
TheRouter.openURL(value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;路由适配不同的 Android-Path&lt;/h3&gt;

&lt;p&gt;在实际开发中，一旦使用 URI 这种方式，牵扯到双端，就可以存在双端不一致的问题，那么如何解决呢，可以通过本地新增多路由 path 解决，也可以通过远端下发新路由解决。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;public class TheRouterControllerB: TheRouterBController, TheRouterable {

    public static var patternString: [String] {
        [&quot;scheme://router/demo2&quot;,
         &quot;scheme://router/demo2Android&quot;]
    }

    public static func registerAction(info: [String : Any]) -&amp;gt; Any {
        let vc =  TheRouterBController()
        vc.desLabel.text = info.description
        return vc
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let relocationMap = [&quot;routerType&quot;: 2, &quot;className&quot;: &quot;TheRouter_Example.TheRouterControllerD&quot;, &quot;path&quot;: &quot;scheme://router/demo5&quot;] as NSDictionary
TheRouterManager.addRelocationHandle(routerMapList: [relocationMap])
TheRouter.openURL(&quot;scheme://router/demo2Android?desc=demo5是Android一个界面的path,为了双端统一，我们动态增加一个path,这样远端下发时demo5也就能跳转了&quot;)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;服务的动态注册与调用&lt;/h2&gt;

&lt;h3&gt;如何声明服务及实现服务&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;@objc
public protocol AppConfigServiceProtocol: TheRouterServiceProtocol {
    // 打开小程序
    func openMiniProgram(info: [String: Any])
}

final class ConfigModuleService: NSObject, AppConfigServiceProtocol {

    static var seriverName: String {
        String(describing: AppConfigServiceProtocol.self)
    }

    func openMiniProgram(info: [String : Any]) {
        if let window = UIApplication.shared.delegate?.window {
            window?.makeToast(&quot;打开微信小程序&quot;, duration: 1, position: window?.center)
        }
    }
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;如何使用服务&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;/// 使用方式
 if let appConfigService = TheRouter.fetchService(AppConfigServiceProtocol.self){
     appConfigService.openMiniProgram(info: [:])
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务使用了runtime动态注册，所以你不用担心服务没有注册的问题。只需像上述案例一样使用即可。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;public class func registerServices() {

    let expectedClassCount = objc_getClassList(nil, 0)
    let allClasses = UnsafeMutablePointer&amp;lt;AnyClass&amp;gt;.allocate(capacity: Int(expectedClassCount))
    let autoreleasingAllClasses = AutoreleasingUnsafeMutablePointer&amp;lt;AnyClass&amp;gt;(allClasses)
    let actualClassCount: Int32 = objc_getClassList(autoreleasingAllClasses, expectedClassCount)
    var resultXLClass = [AnyClass]()
    for i in 0 ..&amp;lt; actualClassCount {

        let currentClass: AnyClass = allClasses[Int(i)]
        if (class_getInstanceMethod(currentClass, NSSelectorFromString(&quot;methodSignatureForSelector:&quot;)) != nil),
           (class_getInstanceMethod(currentClass, NSSelectorFromString(&quot;doesNotRecognizeSelector:&quot;)) != nil),
           let cls = currentClass as? TheRouterServiceProtocol.Type {
            print(currentClass)
            resultXLClass.append(cls)

            TheRouterServiceManager.default.registerService(named: cls.seriverName, lazyCreator: (cls as! NSObject.Type).init())
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;路由远端调用本地服务：服务接口下发，MQTT,JSBridge&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;let dict = [&quot;ivar1&quot;: [&quot;key&quot;:&quot;value&quot;]]
let url = &quot;scheme://services?protocol=AppConfigLAServiceProtocol&amp;amp;method=openMiniProgramWithInfo:&amp;amp;resultType=0&quot;
TheRouter.openURL((url, dict))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;是否考虑Swift5.9 Macros？&lt;/h2&gt;

&lt;p&gt;从目前的实现方式来看，懒加载加上动态注册，已经解决了注册时的性能问题。即使需要遍历全工程的类，然后处理相关逻辑，也不会超过0.2s。之所以能够通过Class取得path，因为给类声明了静态变量。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clike&quot; data-lang=&quot;clike&quot;&gt;/// 实现TheRouterable协议
extension TheRouterController: TheRouterable {

    static var patternString: [String] {
        [&quot;scheme://router/demo&quot;]
    }

    static func registerAction(info: [String : Any]) -&amp;gt; Any {
        debugPrint(info)

        let vc =  TheRouterController()
        vc.qrResultCallBack = info[&quot;clouse&quot;] as? QrScanResultCallBack
        vc.resultLabel.text = info.description
        return vc
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于作者&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/user/1768489241815070&quot;&gt;货拉拉移动端技术团队&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;开源协议&lt;/h2&gt;

&lt;p&gt;TheRouter 采用Apache2.0协议，详情参考&lt;a href=&quot;LICENSE&quot;&gt;LICENSE&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;交流沟通群&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/wx/wx_ios_group.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;</content><author><name></name></author><category term="框架简介" /><summary type="html">背景 随着社区对支持Swift的需求日益增多，Swift5.0二进制库也具有更好的稳定性和兼容性表现，货拉拉技术团队根据社区反馈及内部讨论，决定开源内部业务使用的Swift版本路由组件，与2023年8月份已发布的Objective-C版本路由组件组成一个完整解决方案。 TheRouter开源团队将把重心放在维护和升级Swift版本的TheRouter上。同时也会持续支持Objective-C版本的易用性，并欢迎社区贡献。 对于使用Objective-C版本TheRouter的用户，建议将版本固定为1.0.0版以确保稳定性。 ## Features TheRouter一个用于模块间解耦和通信，基于Swift协议进行动态懒加载注册路由与打开路由的工具。同时支持通过Service-Protocol寻找对应的模块，并用 protocol进行依赖注入和模块通信。 1. 页面导航跳转能力：支持常规vc或Storyboard的push/present/popToTaget/windowNavRoot/modalDismissBeforePush跳转能力； 2. 路由自动注册能力：懒加载方式动态注册路由，仅当第一次调用OpenURL时进行动态注册； 3. 路由映射文件导出：支持将工程中的路由映射关系导出为文档，支持JSON、Plist格式，方便开发者进行双端的汇总比对、记录等； 4. 服务自动注册能力：动态注册服务，使用runtime方式自动注入； 5. 硬编码消除：将注册的path转为静态字符串常量供业务使用； 6. 动态化能力：支持添加重定向，移除重定向、动态添加路由、动态移除路由、拦截器、错误path修复等； 7. 链式编程：支持链式编程方式拼接URL与参数； 8. 适配Objective-C：OC类可以在Swift中使用继承的方式遵循协议来进行动态注册； 9. 服务调用：支持本地服务调用与远端服务调用；</summary></entry><entry><title type="html">TheRouter iOS 路由介绍</title><link href="http://localhost:4000/docs/2023/07/24/01" rel="alternate" type="text/html" title="TheRouter iOS 路由介绍" /><published>2023-07-24T00:00:00+08:00</published><updated>2023-07-24T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/07/24/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/07/24/01">&lt;h2&gt;功能介绍&lt;/h2&gt;

&lt;p&gt;TheRouter 是货拉拉打造的一款同时支持 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android&quot;&gt;Android&lt;/a&gt; 及 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-ios&quot;&gt;iOS&lt;/a&gt; 的轻量级路由中间件，在iOS端吸取了其他其他语言的特性，支持&lt;a href=&quot;https://juejin.cn/post/6999484997782470669&quot;&gt;注解&lt;/a&gt;功能，极大提升了路由在iOS端的使用体感。摒弃了传统 iOSer 的 target-action 或 protocol 理念，向更广的后台或 Android 应用对齐。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TheRouter 核心功能具备四大能力：&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;页面导航跳转能力&lt;/strong&gt;：支持常规 VC 或 Storyboard 的 push/present 跳转能力；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动注册能力&lt;/strong&gt;：实现类似 Java 注解功能，在 VC 类或任意方法上标注即可完成路由注册；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;硬编码消除&lt;/strong&gt;：内置脚本会自动将注册的 path 转为静态字符串常量供业务使用；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态化能力&lt;/strong&gt;：支持添加重定向、拦截器等等；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;模块描述&lt;/h2&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;.
├── Classes
│   ├── TheRouter+Annotation.h
│   ├── TheRouter+Annotation.m  // 路由注解器及Path功能扩展
│   ├── TheRouter.h
│   └── TheRouter.m             // 路由库核心代码（增删改查，重定向/拦截器）
└── Resources
    └── scan.py                 // 注解扫描及硬编码处理脚本（该脚本只会被引用不会参与编译和打包）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用介绍&lt;/h2&gt;

&lt;h4&gt;Cocoapods 引入&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;pod&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'TheRouter'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;注解使用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;step1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创建&lt;code&gt;TheRouterAnnotation.plist&lt;/code&gt;文件，必须在MainBundle下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为项目创建一个Aggregate类型的target：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/image/guide1.jpeg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在新建的target添加脚本：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/image/guide2.jpeg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;图中实例脚本参数含义：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;python3 &lt;span class=&quot;nv&quot;&gt;$SRCROOT&lt;/span&gt;/../TheRouter/Resources/scan.py     &lt;span class=&quot;c&quot;&gt;# 脚本路径&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$SRCROOT&lt;/span&gt;/                                           &lt;span class=&quot;c&quot;&gt;# 参数1：扫描路径,一般为项目根目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$SRCROOT&lt;/span&gt;/TheRouter/                                 &lt;span class=&quot;c&quot;&gt;# 参数2：路径定义头文件存放目录 一般为存放至公共模块 &lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$SRCROOT&lt;/span&gt;/TheRouter/TheRouterAnnotation.plist        &lt;span class=&quot;c&quot;&gt;# 参数3：TheRouterAnnotation文件路径&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在应用加载完成时注册host，在想要跳转的VC类上添加路由注解或创建对应模块的Service类，在Service中的方法上添加注解即可，例如：&lt;/p&gt;

&lt;p&gt;注册该项目的host：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;[TheRouter.shared registPathAnnotationsWithHost:@&quot;hd://com.therouter.test&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加vc注解：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;TheRouterController(test/vc, TestViewController)
@interface TestViewController : UIViewController

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加Service注解：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;#import &quot;TestService.h&quot;
#import &quot;TheRouter_Mappings.h&quot;
#import &amp;lt;TheRouter/TheRouter+Annotation.h&amp;gt;

@implementation TestService

TheRouterSelector(test/jump, jumpToTestVC, TestService)
+ (id)jumpToTestVC:(TheRouterInfo *)routerInfo
{
    UIViewController *vc = [TheRouter.shared openVCPath:kRouterPathTestVcVC
                                                    cmd:TheRouterOpenCMDPush
                                             withParams:@{@&quot;title&quot;:@&quot;123&quot;}
                                                hanlder:^(NSString * _Nonnull tag, NSDictionary * _Nullable result) {
        !routerInfo.openCompleteHandler ?: routerInfo.openCompleteHandler(tag, result);
    }];
    return vc;
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在每次对路由进行增删改时编译一次创建好的target，会自动向&lt;code&gt;TheRouterAnnotation.plist&lt;/code&gt;文件写入信息，并在指定的目录下生成&lt;code&gt;TheRouter_Mappings.h&lt;/code&gt;文件，将此文件拖入对应模块即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/image/guide3.jpeg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h4&gt;拦截器和重定向&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;拦截器：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;// 只要访问hd://com.therouter.test或其子路径 (hd://com.therouter.test/xxx) 都会进入该回调
// 如果返回YES那么对应的路由事件可以正常执行，反之则会被拦截不会执行路由事件
[TheRouter.shared registInterceptorForURLString:@&quot;hd://com.therouter.test/*&quot; handler:^BOOL(TheRouterInfo * _Nonnull router, id  _Nullable (^ _Nonnull continueHandle)(void)) {
    NSLog(@&quot;will execute router %@&quot;, router.URLString);
    return YES;
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重定向：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;// 重定向是指访问 hd://test.com/test 时会走 hd://test.com/test/vc的事件，用来迁移老路径或线上遇到问题时可快速更改至其他页面承接业务
[TheRouter.shared registRedirect:@&quot;hd://test.com/test&quot; to:@&quot;hd://test.com/test/vc&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;执行路由事件&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-C&quot; data-lang=&quot;C&quot;&gt;UIViewController *vc = [TheRouter.shared openVCPath:kRouterPathTestVcVC    // 传入Path
                                                cmd:TheRouterOpenCMDPush   // 指定打开命令
                                         withParams:@{@&quot;title&quot;:@&quot;123&quot;}     // 指定参数，这里支持对kvc赋值
                                            hanlder:^(NSString * _Nonnull tag, NSDictionary * _Nullable result) {
        !routerInfo.openCompleteHandler ?: routerInfo.openCompleteHandler(tag, result);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><author><name></name></author><category term="框架简介" /><summary type="html">功能介绍</summary></entry><entry><title type="html">TheRouter 常见问题处理</title><link href="http://localhost:4000/docs/2023/07/21/01" rel="alternate" type="text/html" title="TheRouter 常见问题处理" /><published>2023-07-21T00:00:00+08:00</published><updated>2023-07-21T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/07/21/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/07/21/01">&lt;p&gt;如无法解决你的问题，建议登记应用，获取优先技术支持 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/57&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/57&lt;/a&gt;    &lt;/p&gt;

&lt;h3&gt;问题列表不定期更新中...&lt;/h3&gt;

&lt;hr&gt;

&lt;h4&gt;Q1: &lt;strong&gt;路由表不生成（或生成的代码有问题编译报错）&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;(注：1.2.0-rc5版本已修复：&lt;code&gt;KSP&lt;/code&gt;与&lt;code&gt;ViewBinding&lt;/code&gt;共用不生成路由表的问题)  &lt;/p&gt;

&lt;p&gt;请按照以下步骤排查：   &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;plugin 加了吗？plugin 必须加且只能加在 app 模块里。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;kapt加了吗？kapt不能只加最底层，所有用了注解的模块都要加。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;router、plugin、kapt，三个依赖的版本号必须一致。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;在这里查看JDK信息：&lt;code&gt;Preferences-&amp;gt; Build Tools-&amp;gt; Gradle-&amp;gt; Gradle JDK&lt;/code&gt;。不能用AS自带的jdk，KSP会有兼容问题，请在 Oracle 官网下载：&lt;a href=&quot;https://www.oracle.com/hk/java/technologies/downloads/#java17&quot;&gt;Java 17&lt;/a&gt;、&lt;a href=&quot;https://www.oracle.com/hk/java/technologies/downloads/#java11&quot;&gt;Java 11&lt;/a&gt;、&lt;a href=&quot;https://www.oracle.com/hk/java/technologies/downloads/#java8&quot;&gt;Java 8&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;尝试更新至最新rc版本查看是否修复。&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&quot;&gt;版本列表&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr&gt;

&lt;h4&gt;Q2：&lt;strong&gt;kotlin使用&lt;code&gt;@Autowired&lt;/code&gt;注解编译不通过&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;查看 GitHub Issue：&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/6&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/6&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;Q3：&lt;strong&gt;使用Gradle 8.X，编译报错&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/22&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/22&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;Q4：&lt;strong&gt;从 ARouter 迁移 TheRouter 时通过 Bundle 传递的参数不能正确获取&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/29&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/issues/29&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;Q5：&lt;strong&gt;多进程如何使用&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://therouter.cn/docs/2022/09/03/01&quot;&gt;https://therouter.cn/docs/2022/09/03/01&lt;/a&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;Q6：&lt;strong&gt;同一个服务名有多个服务提供方，如何使用&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;请查看文档 【1.3 服务提供方】章节的内容：&lt;a href=&quot;https://therouter.cn/docs/2022/08/27/01&quot;&gt;https://therouter.cn/docs/2022/08/27/01&lt;/a&gt;   &lt;/p&gt;

&lt;hr&gt;

&lt;h4&gt;Q7：多进程使用 TheRouter&lt;/h4&gt;

&lt;p&gt;TheRouter 路由支持多进程，但默认只会在主进程执行初始化逻辑。如果使用了多进程，可以先关闭&lt;code&gt;TheRouter&lt;/code&gt;的自动初始化，然后手动在&lt;code&gt;Application&lt;/code&gt;的&lt;code&gt;onCreate()&lt;/code&gt;中执行初始化功能。   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;attachBaseContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;base:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;attachBaseContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;theRouterUseAutoInit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1、多进程&lt;code&gt;ServiceProvider&lt;/code&gt;，TheRouter 支持跨进程获取数据，但获取的数据本身需要支持跨进程，可以理解为&lt;code&gt;TheRouter&lt;/code&gt;本质是个链接两个进程的通道，要将数据从一个进程传递到另一个进程，这个数据本身需要能够被另一个进程接收的到。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;2、&lt;code&gt;FlowTask&lt;/code&gt;的跨进程依赖暂不支持，预计支持版本在&lt;code&gt;1.2.2&lt;/code&gt;。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;3、&lt;code&gt;ActionManager&lt;/code&gt;的跨进程响应暂不支持，预计支持版本在&lt;code&gt;1.2.2&lt;/code&gt;。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;h4&gt;Q8：自定义Log输出&lt;/h4&gt;

&lt;p&gt;默认情况下，&lt;code&gt;TheRouter&lt;/code&gt;会在&lt;code&gt;debug&lt;/code&gt;模式下，将&lt;code&gt;log&lt;/code&gt;打印到控制台，在&lt;code&gt;release&lt;/code&gt;模式下不做任何输出。&lt;br&gt;
如果你希望采集线上日志信息，可以自定义&lt;code&gt;release&lt;/code&gt;场景下的日志输出方式：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这一步建议放在Application.onCreate()之前，否则可能会在赋值之前就有部分日志已经执行了默认逻辑。&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;logCat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;  
        &lt;span class=&quot;c1&quot;&gt;// 执行上报日志的逻辑&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q9：判断String，是否为路由path&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 判断是否为路由落地页path&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isRouterPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;  

&lt;span class=&quot;c1&quot;&gt;// 判断是否为 Action&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isRouterAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q10：导出路由历史记录&lt;/h4&gt;

&lt;p&gt;如果需要记录用户历史操作信息，用于排查错误时回放，可以直接使用历史记录导出功能：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// level共8个状态可选&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NONE&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 不导出任何数据&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTIVITY&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//仅导出Activity的路由操作&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FRAGMENT&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//仅导出Fragment的路由操作&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGE&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 导出 Fragment + Activity的路由操作&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 导出 ActionManager 的操作记录&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SERVICE_PROVIDER&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 导出 ServiceProvider的记录&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FLOW_TASK&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 导出 FlowTaskExecutor 的历史记录&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 导出全部记录&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 8种状态可互相叠加，例如&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTIVITY&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FLOW_TASK&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;export&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;level&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;forEach&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'\n'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q11：导入导出 Intent 对象到路由&lt;/h4&gt;

&lt;p&gt;有一些特殊的业务场景可能必须使用&lt;code&gt;Intent&lt;/code&gt;对象作为参数，例如通知栏点击以后，系统只提供了&lt;code&gt;Intent&lt;/code&gt;参数，或者用于替代&lt;code&gt;startActivityForResult()&lt;/code&gt;的新 API &lt;code&gt;ActivityResultLauncher&lt;/code&gt; 。&lt;br&gt;
TheRouter 也支持这样的使用场景：  &lt;/p&gt;

&lt;p&gt;导入 Intent：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withXxxxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出 Intent：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 注：导出Intent时，需要url有对应的落地页，否则Intent不会附带withXXX()的参数信息&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withXxxxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createIntent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q12：插件化项目集成&lt;/h4&gt;

&lt;p&gt;TheRouter 的路由表是完全动态化的，所以允许动态加载插件路由表。
现有市面上插件化框架较多，具体可参考使用的插件化方案，当插件被加载时分别调用如下代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 在异步线程执行&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;execute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化插件内的依赖注入&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouterServiceProvideInjecter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;trojan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化插件内的FlowTask&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouterServiceProvideInjecter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addFlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;digraph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 初始化插件内的路由表&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouterServiceProvideInjecter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;initDefaultRouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q13：Flutter/RN/WEEX 等混编项目集成&lt;/h4&gt;

&lt;p&gt;TheRouter 的路由表是完全动态化的，所以允许动态加载跨平台项目的路由表。&lt;/p&gt;

&lt;p&gt;可以直接将路由表配置到&lt;code&gt;/assets/RouteMap.json&lt;/code&gt;文件中。&lt;br&gt;
如果路由表的 &lt;code&gt;url&lt;/code&gt; 是具备规律的，可简单使用正则表达式一次性加载。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;path&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;https://kymjs.com/flutter/\\S*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;className&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;com.therouter.FlutterActivity&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;description&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;params&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;key&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;......&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;添加其他路由表&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;......&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr&gt;

&lt;h4&gt;Q14：我的项目使用的Gradle8.x（或AGP8），引入插件失败&lt;/h4&gt;

&lt;p&gt;请完整查看接入文档&lt;a href=&quot;https://therouter.cn/docs/2022/11/23/01&quot;&gt;https://therouter.cn/docs/2022/11/23/01&lt;/a&gt;，并仔细阅读【第一步：接入classpath】   &lt;/p&gt;

&lt;hr&gt;</content><author><name></name></author><category term="框架简介" /><summary type="html">如无法解决你的问题，建议登记应用，获取优先技术支持 https://github.com/HuolalaTech/hll-wp-therouter-android/issues/57</summary></entry><entry><title type="html">TheRouter 使用 KSP 处理注解</title><link href="http://localhost:4000/docs/2023/05/15/01" rel="alternate" type="text/html" title="TheRouter 使用 KSP 处理注解" /><published>2023-05-15T00:00:00+08:00</published><updated>2023-05-15T00:00:00+08:00</updated><id>http://localhost:4000/docs/2023/05/15/01</id><content type="html" xml:base="http://localhost:4000/docs/2023/05/15/01">&lt;p&gt;TheRouter 在&lt;code&gt;1.1.4-rc2&lt;/code&gt;开始，已经将&lt;code&gt;KSP&lt;/code&gt;能力合并至主分支，不再是单独的功能分支了，下面介绍一下如何使用 &lt;code&gt;KSP&lt;/code&gt;。  &lt;/p&gt;

&lt;h3&gt;什么是KSP&lt;/h3&gt;

&lt;p&gt;KSP全称：Kotlin Symbol Processing。&lt;br&gt;
借助官网的描述：KSP 提供了一种基于 Kotlin 的轻量级的编译期插件 API，其编译速度最快可以达到 kapt 速度的两倍。    &lt;/p&gt;

&lt;p&gt;从原理角度讲，&lt;code&gt;Android&lt;/code&gt;项目构建过程中，可用的注解处理器总共有三种：APT、KAPT、KSP。&lt;br&gt;
APT 比较好理解，就是 JDK 提供的注解处理器，通常在 Gradle 项目中不需要引入什么额外插件，只需要在依赖时使用 &lt;code&gt;annotationProcessor &amp;quot;cn.therouter:apt:x.x.x&lt;/code&gt;，但是他不支持 Kotlin 注解的解析。&lt;br&gt;
KAPT 最早是 Kotlin 推出的APT，用于兼容 Kotlin 代码的注解，但是他的实现比较简单粗暴，内部实际上是包了一层APT，他编译时首先处理 Kotlin 的注解解析，如果无法解析，再用APT去解析，所以相当于同一个模块，如果是Java、Kotlin混编时，会执行两遍注解解析。&lt;br&gt;
KSP 是基于语法分析的注解解析，严格来讲，他不仅仅可以用来做注解解析，还可以做一些基于语法分析的事情，比如自定义的代码语法检查，相当于替代了一部分 lint 可以做的事情。正因为基于语法分析来做的，所以性能必然是比 KAPT 高，毕竟编译期一定会先走一遍语法分析。   &lt;/p&gt;

&lt;h3&gt;TheRouter 的 KSP 使用&lt;/h3&gt;

&lt;h4&gt;第一步&lt;/h4&gt;

&lt;p&gt;在项目中所有使用了注解的模块，对应的&lt;code&gt;build.gradle&lt;/code&gt;文件中都需要加入如下依赖，&lt;strong&gt;所有模块都要添加，不能只添加子模块&lt;/strong&gt;：  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ，使用&lt;code&gt;KSP&lt;/code&gt;以后，如果之前使用了&lt;code&gt;kapt&lt;/code&gt;需要将原本的&lt;code&gt;kapt&lt;/code&gt;依赖删掉&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Gradle7.x以下版本，这样加入 KSP插件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;devtools&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ksp&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 删除之前的kapt依赖(如有)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// apply plugin: 'kotlin-kapt' &lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Gradle7.x及以上版本，提供了新的方式，也这样加入 KSP插件&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 当然，也可以继续使用上面那种方式&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plugins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.google.devtools.ksp&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 删除之前的kapt依赖(如有)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//id 'org.jetbrains.kotlin.kapt'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 从1.1.4-rc2 开始在正式版本支持ksp，此前需要使用beta版本，但用法一致&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ksp&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cn.therouter:apt:1.1.4-rc4&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 删除之前的kapt依赖(如有)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// kapt &quot;cn.therouter:apt:1.1.4-rc4&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;第二步&lt;/h4&gt;

&lt;p&gt;在项目根目录&lt;code&gt;build.gradle&lt;/code&gt;引入 kapt 插件的 classpath : &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，版本号需要在KSP官网&lt;a href=&quot;https://github.com/google/ksp/releases&quot;&gt;https://github.com/google/ksp/releases&lt;/a&gt;，找到跟自己项目中 Kotlin 版本号对应的&lt;code&gt;KSP&lt;/code&gt;插件版本号。例如，我的 Kotlin 版本号是 &lt;code&gt;1.5.31&lt;/code&gt;，所以 KSP 插件的版本号就使用对应的&lt;code&gt;1.5.31-1.0.0&lt;/code&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// Gradle7.x以下版本，这样加入 &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;buildscript&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dependencies&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.google.devtools.ksp:symbol-processing-gradle-plugin:xxx-xxx&quot;&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Gradle7.x及以上版本，提供了新的方式，也这样加入  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 当然，也可以继续使用上面那种方式&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;plugins&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;com.google.devtools.ksp&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxx&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><author><name></name></author><category term="基础能力介绍" /><summary type="html">TheRouter 在1.1.4-rc2开始，已经将KSP能力合并至主分支，不再是单独的功能分支了，下面介绍一下如何使用 KSP。</summary></entry><entry><title type="html">动态路由 TheRouter 的设计与实践</title><link href="http://localhost:4000/docs/2022/12/23/01" rel="alternate" type="text/html" title="动态路由 TheRouter 的设计与实践" /><published>2022-12-23T00:00:00+08:00</published><updated>2022-12-23T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/12/23/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/12/23/01">&lt;p&gt;内容请见： &lt;/p&gt;

&lt;p&gt;《动态路由 TheRouter 的设计与实践》&lt;br&gt;
&lt;a href=&quot;https://kymjs.com/session/2022/11/23/01/&quot;&gt;https://kymjs.com/session/2022/11/23/01/&lt;/a&gt;&lt;/p&gt;</content><author><name>张涛</name></author><category term="原理与项目实践讲解" /><summary type="html">内容请见：</summary></entry><entry><title type="html">从零接入 TheRouter</title><link href="http://localhost:4000/docs/2022/11/23/01" rel="alternate" type="text/html" title="从零接入 TheRouter" /><published>2022-11-23T00:00:00+08:00</published><updated>2022-11-23T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/11/23/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/11/23/01">&lt;p&gt;TheRouter是货拉拉开源的路由框架，针对 Android 平台实现组件化、跨模块调用、动态化等功能的集成框架，基本上算当前最先进的路由库了。&lt;br&gt;
Github: &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/&lt;/a&gt;&lt;br&gt;
官网：&lt;a href=&quot;http://therouter.cn/&quot;&gt;http://therouter.cn/&lt;/a&gt;  &lt;/p&gt;

&lt;h2&gt;开始之前&lt;/h2&gt;

&lt;p&gt;如果你的项目之前使用过其他路由，建议使用迁移工具一键迁移： &lt;a href=&quot;https://therouter.cn/docs/2022/09/05/01&quot;&gt;https://therouter.cn/docs/2022/09/05/01&lt;/a&gt;   &lt;/p&gt;

&lt;p&gt;如果你的是新项目，请先记住一点：&lt;strong&gt;plugin、apt、router 三个依赖的版本号必须保持一致&lt;/strong&gt;，请继续往下看接入步骤。   &lt;/p&gt;

&lt;h2&gt;查看最新版本&lt;/h2&gt;

&lt;p&gt;TheRouter 的版本分为两种，稳定版和 rc版，一般不追求新功能我们就用稳定版就行，可以在官网看到最新的版本号和各种版本的说明：&lt;a href=&quot;https://therouter.cn/docs/2022/09/06/01&quot;&gt;https://therouter.cn/docs/2022/09/06/01&lt;/a&gt;  &lt;/p&gt;

&lt;h2&gt;接入&lt;/h2&gt;

&lt;p&gt;新建一个&lt;code&gt;Demo&lt;/code&gt;工程，打开&lt;code&gt;Demo&lt;/code&gt;的根目录&lt;code&gt;build.gradle&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;第一步：接入classpath&lt;/h3&gt;

&lt;h4&gt;8.X 版本 Gradle&lt;/h4&gt;

&lt;p&gt;由于 8.X 版本的 Gradle，必须使用&lt;code&gt;Java 17&lt;/code&gt;的环境了，并且不兼容老&lt;code&gt;JDK&lt;/code&gt;编译的&lt;code&gt;class&lt;/code&gt;，所以对于新版本需要使用专为&lt;code&gt;Java 17&lt;/code&gt;编译的插件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cn.therouter.agp8'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1.2.1'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/1.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h4&gt;7.X 版本 Gradle&lt;/h4&gt;

&lt;p&gt;7.X 的 Gradle，&lt;code&gt;classpath&lt;/code&gt;已经改为用&lt;code&gt;plugins&lt;/code&gt;的方式引入，只需要在闭包内加这一句就行了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'cn.therouter'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1.2.1'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/2.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h4&gt;6.x 及之前的老版本 Gradle&lt;/h4&gt;

&lt;p&gt;对于6.x 及之前的  Gradle，需要手动引入&lt;code&gt;classpath&lt;/code&gt;，在 TheRouter 官方 Github 首页也有接入介绍&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;classpath&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cn.therouter:plugin:1.2.1&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/3.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第二步：引入插件&lt;/h3&gt;

&lt;h4&gt;7.X 及以后版本 Gradle&lt;/h4&gt;

&lt;p&gt;找到项目里全部的app模块（一般只会有一个，特殊项目会有多个）。也就是整个工程的所有&lt;code&gt;build.gradle&lt;/code&gt;文件里面，只要是有&lt;code&gt;com.android.application&lt;/code&gt;这个的模块，都要加上如下代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 7.X及以上新版本这样写&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'therouter'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/4.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h4&gt;6.x 及之前的老版本 Gradle&lt;/h4&gt;

&lt;p&gt;找到项目里全部的app模块（一般只会有一个，特殊项目会有多个）。也就是整个工程的所有&lt;code&gt;build.gradle&lt;/code&gt;文件里面，只要是有&lt;code&gt;com.android.application&lt;/code&gt;这个的模块，都要加上如下代码&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 6.X及以下老版本这样写&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;apply&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;plugin:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'therouter'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/5.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h3&gt;第三步：引入注解处理器&lt;/h3&gt;

&lt;p&gt;最新版的 TheRouter 已经支持&lt;code&gt;KSP&lt;/code&gt;解析，如果你都不知道&lt;code&gt;KSP&lt;/code&gt;是什么，那么就继续往下看，使用&lt;code&gt;kapt&lt;/code&gt;吧。如果你希望使用&lt;code&gt;KSP&lt;/code&gt;，可以看文档：&lt;a href=&quot;https://therouter.cn/docs/2023/05/15/01&quot;&gt;使用 KSP 处理注解&lt;/a&gt;。  &lt;/p&gt;

&lt;p&gt;TheRouter 的注解处理依赖&lt;code&gt;kapt&lt;/code&gt;执行，所以要在项目里面手动引入，否则无法处理注解。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：所有的模块都必须引入kapt，否则就有可能造成某些路由表不生成。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;注：所有APP的模块，如果是需要上线的模块，必须直接或间接在 app 中被依赖，否则最终生成apk会丢失未被依赖的功能。&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://therouter.cn/assets/img/image/6.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果报找不到kapt，可能是因为没有声明kotlin-kapt的插件，参考&lt;code&gt;步骤二&lt;/code&gt;里面的截图，接入对应的kapt。&lt;br&gt;
如果是纯Java工程，需要用Java的APT处理，纯Java就不用声明&lt;code&gt;kotlin-kapt&lt;/code&gt;插件了，直接把&lt;code&gt;kapt&lt;/code&gt;改成&lt;code&gt;annotationProcessor&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-groovy&quot; data-lang=&quot;groovy&quot;&gt;&lt;span class=&quot;n&quot;&gt;annotationProcessor&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;cn.therouter:apt:1.2.1&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;第四步：引入路由库&lt;/h3&gt;

&lt;p&gt;在需要使用路由功能的模块的&lt;code&gt;build.gradle&lt;/code&gt;，(不像kapt，这个是可以使用传递依赖的)，加入如下依赖  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;dependencies {
    implementation &quot;cn.therouter:router:1.2.1&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用&lt;/h2&gt;

&lt;h4&gt;1. 声明路由&lt;/h4&gt;

&lt;p&gt;给需要跳转的页面加上路由表声明&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Route&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://therouter.com/home&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HomeActivity&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BaseActivity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2. 添加参数注入&lt;/h4&gt;

&lt;p&gt;这一步如果在base里面写了的话就不用每个Activity都加了。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 发起跳转&lt;/h4&gt;

&lt;p&gt;也就是原来使用startActivity()的方法，都可以改成这样使用了&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;要跳转的目标页Path&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;intValue&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12345678&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;str_123_Value&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;传中文字符串&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withBoolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;boolValue&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withLong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;longValue&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123456789012345L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withChar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;charValue&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'c'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withDouble&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;double&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.14159265358972&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withFloat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;floatValue&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;3.14159265358972&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;如果没有参数，可以什么都不传&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;AGP 8.X 使用&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;从1.2.1开始，beta版本已经全部合入rc版本，无需再特殊关注beta版本进度。&lt;/em&gt;    &lt;/p&gt;

&lt;p&gt;使用时只需注意本文第一步中，classpath引入的不同，需要使用&lt;code&gt;cn.therouter.agp8&lt;/code&gt;引入插件。   &lt;/p&gt;</content><author><name></name></author><category term="入门教程" /><summary type="html">TheRouter是货拉拉开源的路由框架，针对 Android 平台实现组件化、跨模块调用、动态化等功能的集成框架，基本上算当前最先进的路由库了。 Github: https://github.com/HuolalaTech/hll-wp-therouter-android/ 官网：http://therouter.cn/</summary></entry><entry><title type="html">Android Studio 插件，开发必备工具</title><link href="http://localhost:4000/docs/2022/09/29/01" rel="alternate" type="text/html" title="Android Studio 插件，开发必备工具" /><published>2022-09-29T00:00:00+08:00</published><updated>2022-09-29T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/09/29/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/09/29/01">&lt;p&gt;开发了一个用于自动跳转的辅助插件，可以直接从 路由 的声明处查看到哪些地方使用了本次跳转。   &lt;/p&gt;

&lt;iframe width=&quot;384px&quot; height=&quot;319px&quot; src=&quot;https://plugins.jetbrains.com/embeddable/card/20047&quot;&gt;&lt;/iframe&gt;

&lt;h2&gt;下载插件&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;打开 Android Studio -&amp;gt; Preferences -&amp;gt;  Plugins  -&amp;gt; Marketplace&lt;/li&gt;
&lt;li&gt;搜索 &lt;code&gt;TheRouter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;点击下载&lt;/li&gt;
&lt;li&gt;重启 Android Studio&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;一键迁移工具&lt;/h2&gt;

&lt;p&gt;AndroidStudio 插件的全新版本，已完美支持一键迁移工具，无需再次单独下载额外工具使用。&lt;br&gt;
下载安装最新插件后，在顶部菜栏即可看到&lt;code&gt;TheRouter&lt;/code&gt;菜单，选择对应路由的一键迁移选项即可使用。   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin11.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;导航快捷跳转&lt;/h2&gt;

&lt;p&gt;安装好插件后打开项目，就可以看到，在项目中所有调用了 &lt;code&gt;TheRouter.build(path)&lt;/code&gt; 的地方，&lt;br&gt;
还有 &lt;code&gt;@Route(path = &amp;quot;xxxxx&amp;quot;)&lt;/code&gt; 注解的位置，&lt;br&gt;
在左侧侧边栏上都会有一个绿色箭头的图标。    &lt;/p&gt;

&lt;p&gt;如果把鼠标放在图标上一段时间，就可以看到提示：&lt;br&gt;
点击以后跳转到使用这个&lt;code&gt;path&lt;/code&gt;的地方，&lt;br&gt;
或者跳转到&lt;code&gt;path&lt;/code&gt;定义的位置，点击以后就能自动跳转了。&lt;br&gt;
如下图：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin1.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果在代码中有多个地方都可以跳转到当前落地页，点击箭头后会有一个选择框，&lt;br&gt;
可以选择跳转到使用当前&lt;code&gt;path&lt;/code&gt;的位置。&lt;br&gt;
例如这张图：   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin2.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果当前&lt;code&gt;path&lt;/code&gt;是个没有被声明的，或者是由字符串拼接的，可能会出现无法找到定义位置的情况，此时在侧边栏会出现黄色的警告提示，&lt;br&gt;
需要开发人工去检查这个&lt;code&gt;path&lt;/code&gt;是不是忘记定义落地页了，还是说手误写错了&lt;code&gt;path&lt;/code&gt;。&lt;br&gt;
例如这张图：   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin3.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;获取最新版本&lt;/h2&gt;

&lt;p&gt;再也无需时时刻刻关注 TheRouter 版本更新情况了，只需要手动点击菜单，即可实时知晓当前最新版本号。   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin10.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterIdeaPlugin12.png&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h2&gt;插件开源&lt;/h2&gt;

&lt;p&gt;本插件项目已基于 &lt;code&gt;Apache License 2.0&lt;/code&gt; 协议开源，并上架插件市场，欢迎 star 与下载   &lt;/p&gt;

&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/kymjs/TheRouterIdeaPlugin&quot;&gt;https://github.com/kymjs/TheRouterIdeaPlugin&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="辅助工具" /><summary type="html">开发了一个用于自动跳转的辅助插件，可以直接从 路由 的声明处查看到哪些地方使用了本次跳转。</summary></entry><entry><title type="html">获取和使用最新版的 TheRouter</title><link href="http://localhost:4000/docs/2022/09/06/01" rel="alternate" type="text/html" title="获取和使用最新版的 TheRouter" /><published>2022-09-06T00:00:00+08:00</published><updated>2022-09-06T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/09/06/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/09/06/01">&lt;p&gt;TheRouter 的版本规划分为三种，分别是 &lt;code&gt;稳定版&lt;/code&gt;、&lt;code&gt;预览版&lt;/code&gt;(含 beta 版)、&lt;code&gt;公测版&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;稳定版&lt;/h3&gt;

&lt;p&gt;稳定版总是在&lt;code&gt;main&lt;/code&gt;分支打包发布，最新的稳定版本就是&lt;code&gt;main&lt;/code&gt;分支的最新代码。   &lt;/p&gt;

&lt;p&gt;你可以在 GitHub 的 releases 页面找到最新的稳定版本。&lt;br&gt;
&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;稳定版的版本号格式为&lt;code&gt;x.y.z&lt;/code&gt;，最新的稳定版本会有绿色的&lt;code&gt;Latest&lt;/code&gt;标记。     &lt;/p&gt;

&lt;h3&gt;预览版&lt;/h3&gt;

&lt;p&gt;预览版为一段时间的&lt;code&gt;feature&lt;/code&gt;和&lt;code&gt;bugfix&lt;/code&gt;整合，表示即将被合并到&lt;code&gt;main&lt;/code&gt;分支的代码。  &lt;/p&gt;

&lt;p&gt;最新的预览版会在 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&quot;&gt; GitHub 的 releases 页面&lt;/a&gt; 标记为&lt;code&gt;Pre-release&lt;/code&gt;，预览版版本号一般会带有&lt;code&gt;-rc&lt;/code&gt;标记。  &lt;/p&gt;

&lt;p&gt;预览版可以直接在 &lt;code&gt;mavenCentral()&lt;/code&gt; 仓库获取，无需特殊处理。适合追求新功能和特定 bug 修复的开发者使用。  &lt;/p&gt;

&lt;h3&gt;beta预览版&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;beta&lt;/code&gt;预览版一般指在最近一段时间内不会发布&lt;code&gt;release&lt;/code&gt;，但可供尝鲜用户使用某些特定功能的版本。  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;beta&lt;/code&gt;预览版会在 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&quot;&gt; GitHub 的 releases 页面&lt;/a&gt; 标记为&lt;code&gt;Pre-release&lt;/code&gt;，预览版版本号一般会带有&lt;code&gt;-beta&lt;/code&gt;标记。  &lt;/p&gt;

&lt;p&gt;预览版可以直接在&lt;code&gt;mavenCentral()&lt;/code&gt;仓库获取，无需特殊处理。适合追求新功能和特定 bug 修复的开发者使用。  &lt;/p&gt;

&lt;h3&gt;公测版&lt;/h3&gt;

&lt;p&gt;公测版为每次新&lt;code&gt;feature&lt;/code&gt;或&lt;code&gt;bugfix&lt;/code&gt;的打包，不会在 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/releases&quot;&gt;releases 页&lt;/a&gt; 单独展示，你可以主动在maven上查看最新的公测版本。   &lt;/p&gt;

&lt;p&gt;公测版版本号一般不会有特殊标记，但需要在&lt;code&gt;build.gradle&lt;/code&gt;中引入公测版仓库。  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-gradle&quot; data-lang=&quot;gradle&quot;&gt;&lt;span class=&quot;k&quot;&gt;repositories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mavenCentral&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;maven&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'https://s01.oss.sonatype.org/content/groups/staging/'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看最新公测版本：&lt;a href=&quot;https://s01.oss.sonatype.org/content/groups/staging/cn/therouter/&quot;&gt;https://s01.oss.sonatype.org&lt;/a&gt;  &lt;/p&gt;</content><author><name></name></author><category term="版本介绍" /><summary type="html">TheRouter 的版本规划分为三种，分别是 稳定版、预览版(含 beta 版)、公测版。</summary></entry><entry><title type="html">TheRouter 一键迁移工具</title><link href="http://localhost:4000/docs/2022/09/05/01" rel="alternate" type="text/html" title="TheRouter 一键迁移工具" /><published>2022-09-05T00:00:00+08:00</published><updated>2022-09-05T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/09/05/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/09/05/01">&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt;提供了图形化界面的迁移工具，可以一键从其他路由迁移到&lt;code&gt;TheRouter&lt;/code&gt;。&lt;br&gt;
全新迁移工具已集成到 AndroidStudio 开发插件中，可直接在AS插件市场下载，相关介绍请访问： &lt;a href=&quot;https://therouter.cn/docs/2022/09/29/01&quot;&gt;https://therouter.cn/docs/2022/09/29/01&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;旧版本图形界面可使用：1.1.1 (2022-10-09更新)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mac OS 迁移工具下载：&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Mac.zip&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Mac.zip&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Windows 迁移工具下载：&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Windows.zip&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Windows.zip&lt;/a&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/TheRouterTransfer.png&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;注意事项&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;issue中有用户反馈：使用&lt;code&gt;Windows&lt;/code&gt;系统迁移时，会发生乱码情况。犹豫迁移工具对文件的读写均采用&lt;code&gt;UTF-8&lt;/code&gt;编码，所以建议在迁移之前先将工程编码设置为&lt;code&gt;UTF-8&lt;/code&gt;。Android Studio支持修改工程编码：&lt;code&gt;Setting -&amp;gt; Editor -&amp;gt; File Encodings&lt;/code&gt; 修改&lt;code&gt;Global Encoding&lt;/code&gt;和&lt;code&gt;Project Encoding&lt;/code&gt;为 &lt;code&gt;UTF-8&lt;/code&gt;&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/img/image/encode.jpg&quot; class=&quot;blog-img&quot;&gt;&lt;/p&gt;

&lt;h3&gt;需要手动修改的部分&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ARouter 的 Provider.init 部分，建议改为懒加载方式，在服务方法被调用时自己主动调用init方法。    &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果使用了 ARouter 拦截器部分，需要自己手动处理拦截器的逻辑，ARouter的拦截器全部可以用 TheRouter 的拦截器替换，具体逻辑请参考：TheRouter页面跳转：【&lt;a href=&quot;https://therouter.cn/docs/2022/08/28/01&quot;&gt;第三部分&lt;/a&gt;】自定义处理器。    &lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ARouter 封装了大量 Bundle 传参的操作，例如&lt;code&gt;withBooleanArray()&lt;/code&gt;这种。我们认为这样的封装是冗余的。如果你使用到了对应方法，在TheRouter内可以直接通过对Bundle对象调用对应的方法。例如：    &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// ARouter &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ARouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withByteArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withStringArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// TheRouter&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fillParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putByteArray&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putStringArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;with(bundle)&lt;/code&gt;的实现区别。在 ARouter 中，with 操作是一个集合性操作，如果此时 bundle 中的 key 与 &lt;code&gt;withString(key, value)&lt;/code&gt; 中的 key 重复，会发生后者覆盖前者的情况。&lt;br&gt;
在&lt;code&gt;TheRouter&lt;/code&gt;中，with 操作是传入一个额外的对象，不会发生覆盖，但在落地页获取时需要通过 &lt;code&gt;@Autowired&lt;/code&gt; 注解获取。&lt;br&gt;
如果你希望&lt;code&gt;with(bundle)&lt;/code&gt;能直接通过intent获取，可以使用如下代码。  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;ARouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;with&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourBundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fillParams&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;putAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;yourBundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;》》》   &lt;/p&gt;

&lt;p&gt;暂未发现其他需要手动修改部分&lt;/p&gt;

&lt;h3&gt;迁移建议&lt;/h3&gt;

&lt;p&gt;为防止在迁移完成后，写代码过程中，导包引用错误的情况。&lt;br&gt;
建议手动检查一遍&lt;code&gt;ARouter&lt;/code&gt;的引用是否全部删除，并在各模块&lt;code&gt;build.gradle&lt;/code&gt;中配置如下代码，过滤掉相关引用。&lt;br&gt;
这样如果发生引用错误问题，会在编译期报错，提前发现问题。   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-&quot; data-lang=&quot;&quot;&gt;configurations {
    all*.exclude group: 'com.alibaba', module: 'arouter-api'
    all*.exclude group: 'com.alibaba', module: 'arouter-annotation'
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content><author><name></name></author><category term="迁移工具" /><summary type="html">TheRouter提供了图形化界面的迁移工具，可以一键从其他路由迁移到TheRouter。 全新迁移工具已集成到 AndroidStudio 开发插件中，可直接在AS插件市场下载，相关介绍请访问： https://therouter.cn/docs/2022/09/29/01 旧版本图形界面可使用：1.1.1 (2022-10-09更新)</summary></entry><entry><title type="html">Android 动态路由框架：TheRouter 开源</title><link href="http://localhost:4000/docs/2022/09/04/01" rel="alternate" type="text/html" title="Android 动态路由框架：TheRouter 开源" /><published>2022-09-04T00:00:00+08:00</published><updated>2022-09-04T00:00:00+08:00</updated><id>http://localhost:4000/docs/2022/09/04/01</id><content type="html" xml:base="http://localhost:4000/docs/2022/09/04/01">&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 是一个 Kotlin 编写，用于 Android 模块化开发的一整套解决方案框架。&lt;br&gt;
Github 项目地址与使用文档详见 &lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android&lt;/a&gt;。    &lt;/p&gt;

&lt;p&gt;TheRouter 核心功能具备如下能力：    &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面导航跳转能力(Navigator)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;跨模块依赖注入能力(ServiceProvider)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;单模块自动初始化能力(FlowTaskExecutor)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;动态化能力(ActionManager)&lt;br&gt;&lt;/li&gt;
&lt;li&gt;模块AAR/源码依赖一键切换脚本&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;一、为什么要使用 TheRouter&lt;/h3&gt;

&lt;p&gt;路由是现如今移动端开发中必不可少的功能，尤其是企业级APP，可以用于将&lt;code&gt;Intent&lt;/code&gt;页面跳转的强依赖关系解耦，同时减少跨团队开发的互相依赖问题。   &lt;/p&gt;

&lt;p&gt;对于大型 APP 开发，基本都会选用模块化(或组件化)方式开发，对于模块间解耦要求更高。 &lt;code&gt;TheRouter&lt;/code&gt; 是一整套完全面向模块化开发的解决方案，不仅能支持常规的模块依赖解耦、页面跳转，同时提供了模块化过程中常见问题的解决办法。例如：完美解决了模块化开发后由于组件内无法获取 &lt;code&gt;Application&lt;/code&gt; 生命周期与业务流程，造成每次初始化与关联依赖调用都需要跨模块修改代码的问题。       &lt;/p&gt;

&lt;h4&gt;1.1 TheRouter 四大能力&lt;/h4&gt;

&lt;p&gt;Navigator：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持 &lt;code&gt;Activity&lt;/code&gt; 和 &lt;code&gt;Fragment&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;支持&lt;code&gt;Path&lt;/code&gt;与页面多对一关系或一对一关系，可用于解决多端path统一问题&lt;/li&gt;
&lt;li&gt;页面&lt;code&gt;Path&lt;/code&gt;支持正则表达式声明&lt;/li&gt;
&lt;li&gt;支持 &lt;code&gt;json&lt;/code&gt; 格式路由表导出&lt;/li&gt;
&lt;li&gt;支持动态下发 &lt;code&gt;json&lt;/code&gt; 路由表，降级任意页面为H5&lt;/li&gt;
&lt;li&gt;支持任意&lt;code&gt;object&lt;/code&gt;跨模块传递（无需序列化，且能保证对象类型）&lt;/li&gt;
&lt;li&gt;支持页面跳转拦截处理&lt;/li&gt;
&lt;li&gt;支持自定义页面参数解析方式（例如将&lt;code&gt;json&lt;/code&gt;解析为对象）&lt;/li&gt;
&lt;li&gt;支持使用路由跳转到第三方 SDK 中的&lt;code&gt;Activity&lt;/code&gt;(&lt;code&gt;Fragment&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ServiceProvider：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持跨模块依赖注入&lt;/li&gt;
&lt;li&gt;支持自定义注入项的创建规则，依赖注入可自定义参数&lt;/li&gt;
&lt;li&gt;支持自定义服务拦截，单模块&lt;code&gt;mock&lt;/code&gt;调试&lt;/li&gt;
&lt;li&gt;支持注入对象缓存，多次注入 只会new一次对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;FlowTaskExecutor：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持单模块独立初始化&lt;/li&gt;
&lt;li&gt;支持懒加载初始化&lt;/li&gt;
&lt;li&gt;独立初始化允许多任务依赖(参考&lt;code&gt;Gradle Task&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;支持编译期循环引用检测&lt;/li&gt;
&lt;li&gt;支持自定义业务初始化时机，可以用于解决隐私合规问题&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ActionManager：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;支持全局回调配置&lt;/li&gt;
&lt;li&gt;支持优先级响应与中断响应&lt;/li&gt;
&lt;li&gt;支持记录调用路径，解决调试期观察者模式无法追踪&lt;code&gt;Observable&lt;/code&gt;的问题 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;code&gt;FlowTaskExecutor&lt;/code&gt;、&lt;code&gt;ActionManager&lt;/code&gt; 后续会作为可选能力，提供&lt;code&gt;可插拔&lt;/code&gt;或&lt;code&gt;单独使用&lt;/code&gt;的选项（预计10月份提供）。&lt;/p&gt;

&lt;h3&gt;二、路由方案&lt;/h3&gt;

&lt;p&gt;目前现有的路由基本上集中于两种能力的实现：页面跳转、跨模块调用，核心技术方案大体上如图：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d819de9d8ea424d8ee0b1b924795967~tplv-k3u1fbpfcp-watermark.image?&quot; class=&quot;blog-img&quot;/&gt; &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;开发阶段，对要使用路由的落地页或被调用方法添加注解标识。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;编译期解析注解，生成一系列中间代码，待调用。&lt;/li&gt;
&lt;li&gt; 应用启动后调用中间代码完成路由的准备动作。大部分路由会额外通过 &lt;code&gt;Gradle Transform&lt;/code&gt;，在编译期做一次聚合，以提升运行时准备路由表的效率。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;发起路由跳转时，本质上就是一次路由表遍历，通过uri获取到对应的落地页或方法对象，进行调用。&lt;br&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 的页面跳转、跨模块调用也是如此，但是在设计上会有一些细节处理。   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e048fba4a04c46738ed9a1e29ebab6e7~tplv-k3u1fbpfcp-watermark.image?&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 会在编译期根据注解生成 &lt;code&gt;RouteMap__&lt;/code&gt;开头的类，这些类中记录了当前模块的所有路由信息，也就是当前模块的路由表。   &lt;/p&gt;

&lt;p&gt;在最顶层的&lt;code&gt;app&lt;/code&gt;模块中，通过&lt;code&gt;Gradle&lt;/code&gt;插件，将所有aar、源码中的&lt;code&gt;RouteMap__&lt;/code&gt;开头的类统一集中到&lt;code&gt;TheRouterServiceProvideInjecter&lt;/code&gt;类中。   &lt;/p&gt;

&lt;p&gt;后续应用启动后，初始化路由时只需要执行&lt;code&gt;TheRouterServiceProvideInjecter&lt;/code&gt;类的方法，就能&lt;strong&gt;没有任何反射&lt;/strong&gt;的加载到全部的路由表了。  &lt;/p&gt;

&lt;p&gt;加载以后的路由表会被保存到一个支持正则匹配的 &lt;code&gt;Map&lt;/code&gt; 中，这也是&lt;code&gt;TheRouter&lt;/code&gt;允许多个&lt;code&gt;path&lt;/code&gt;对应同一个落地页的原因。每当发生页面跳转时，通过跳转时的&lt;code&gt;path&lt;/code&gt;，去&lt;code&gt;Map&lt;/code&gt;中获取到对应的落地页信息，再正常调用&lt;code&gt;startActivity()&lt;/code&gt;即可。   &lt;/p&gt;

&lt;h3&gt;三、使用 TheRouter 页面跳转&lt;/h3&gt;

&lt;h4&gt;3.1 声明路由项&lt;/h4&gt;

&lt;p&gt;如果一个页面（支持 Activity、Fragment）允许被路由打开，则需要使用注解 &lt;code&gt;@Route&lt;/code&gt; 声明路由项，每个页面允许声明多个路由项，也就是一对多的能力，极大降低多端路由统一时的业务影响面。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数释义&lt;/strong&gt;   &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;path&lt;/strong&gt;: 路由path 【必传】。&lt;br&gt;
建议是一个url。path内支持使用正则表达式（为了匹配效率，正则必须包含反双斜杠\），允许多个path对应同一个Activity(Fragment)。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;action&lt;/strong&gt;: 自定义事件【可选】。&lt;br&gt;
一般用来打开目标页面后做一个执行动作，例如自定义页面弹出广告弹窗。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;description&lt;/strong&gt;: 页面描述【可选】。&lt;br&gt;
会被记录到路由表中，方便后期排查的时候知道每个path或Activity是什么业务。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;params&lt;/strong&gt;: 页面参数【可选】。&lt;br&gt;
自动写入&lt;code&gt;intent&lt;/code&gt;中，允许写在路由表中动态下发修改默认值，或通过路由跳转时代码传入。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt; &lt;span class=&quot;nd&quot;&gt;@Route&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://therouter.com/home&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;action://scheme.com&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;第二个页面&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;world&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HomeActivity&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AppCompatActivity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 发起页面跳转&lt;/h4&gt;

&lt;p&gt;传入的参数可以是 &lt;code&gt;String&lt;/code&gt; 和8种基本数据类型、也可以是&lt;code&gt;Bundle&lt;/code&gt;、&lt;code&gt;Serializable&lt;/code&gt;、
&lt;code&gt;Parcelable&lt;/code&gt;对象，跟 &lt;code&gt;Intent&lt;/code&gt; 传值规则一致。&lt;br&gt;
同时也支持为本次跳转的 &lt;code&gt;Intent&lt;/code&gt; 添加&lt;code&gt;Flag/Uri/ClipData/identifier&lt;/code&gt;等业务特殊参数。   &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 传入参数可以通过注解 @Autowired 解析成任意类型，如果是对象建议传json&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// context 参数如果不传或传 null，会自动使用 application 替换&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://therouter.com/home&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12345678&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key2&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;参数&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withBoolean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key3&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withSerializable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;key4&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 这个方法可以传递任意对象，但是接收的地方对象类型需自行保证一致，否则会强转异常&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 如果传入 requestCode，默认使用startActivityForResult启动Activity&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;navigation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 如果要打开的是fragment，需要使用&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createFragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.3 路由表生成规则&lt;/h4&gt;

&lt;p&gt;如果两条路由的&lt;code&gt;path&lt;/code&gt;、目标&lt;code&gt;className&lt;/code&gt;完全相同，则认为是同一条路由，&lt;strong&gt;不会考虑参数是否相同&lt;/strong&gt;。&lt;br&gt;
路由表生成规则：编译期按照如下顺序取&lt;strong&gt;并集&lt;/strong&gt;。   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;覆盖规则&lt;/strong&gt;：&lt;br&gt;
根据如下顺序，如果相同，后者可以覆盖前者的路由表规则。   &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编译期解析注解生成路由表&lt;/li&gt;
&lt;li&gt;首先取 &lt;code&gt;业务模块 aar&lt;/code&gt; 中的路由表&lt;/li&gt;
&lt;li&gt;再取 主&lt;code&gt;app module&lt;/code&gt; 代码中的路由表&lt;/li&gt;
&lt;li&gt;最后取 &lt;code&gt;assets/RouteMap.json&lt;/code&gt; 文件中声明的路由表。

&lt;ul&gt;
&lt;li&gt;如果编译期没有这个文件，会生成一份默认路由表放在这个目录内；如果有，会将路由表合并。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;路由表生成时可配置是否启用检查路由合法性，判断目标页面是否存在，(warning/error)级别。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行时线上动态下发的路由表&lt;br&gt;

&lt;ul&gt;
&lt;li&gt;路由表允许线上动态下发，将覆盖本地路由表，详见 【3.4 动态路由表的设计与使用】&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果编译期没有这个文件，会生成一份默认路由表放在这个目录内；如果有，会将路由表合并，因此，对于没办法修改代码的第三方SDK内部，如果希望通过路由打开，只需要手动在&lt;code&gt;RouteMap.json&lt;/code&gt;文件中声明，就能通过路由打开了。    &lt;/p&gt;

&lt;h4&gt;3.4 动态路由表的设计与使用&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 的路由表是动态添加的，项目每次编译后，会在 apk 内生成一份当前 APP 的全量路由表，默认路径为：&lt;code&gt;/assets/therouter/routeMap.json&lt;/code&gt;。这个路由表也可以后续通过远程下发的方式使用，例如远端可以针对不同的APP版本，下发不同的路由表达到配置目的。这样如果将来线上某些页面发生Crash，可以通过将这个页面的落地页替换为H5的方式，临时解决这类问题。    &lt;/p&gt;

&lt;p&gt;有两种推荐的远程下发方式可供使用方选择：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将打包系统与配置系统打通，每次新版本APP打包后自动将&lt;code&gt;assets/&lt;/code&gt;目录中的配置文件上传到配置系统，下发给对应版本APP 。优点在于全自动不会出错。&lt;/li&gt;
&lt;li&gt;配置系统无法打通，线上手动下发需要修改的路由项，因为 &lt;code&gt;TheRouter&lt;/code&gt; 会自动用最新下发的路由项覆盖包内的路由项。优点在于精确，且流量资源占用小。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：一旦你设置了自定义的&lt;code&gt;InitTask&lt;/code&gt;，原框架内路由表初始化任务将不再执行，你需要自己处理找不到路由表时的兜底逻辑，一种建议的处理方式见如下代码。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 此代码 必须 在 Application.super.onCreate() 之前调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;RouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setInitTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RouterMapInitTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/** 
     * 此方法执行在异步
     */&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;asyncInitRouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 此处为纯业务逻辑，每家公司远端配置方案可能都不一样&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 不建议每次都请求网络，否则请求网络的过程中，路由表是空的，可能造成APP无法跳转页面&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 最好是优先加载本地，然后开异步线程加载远端配置&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Connfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doHttp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;routeMap&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 建议加一个判断，如果远端配置拉取失败，使用包内配置做兜底方案，否则可能造成路由表异常&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TextUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RouteItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fromJson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TypeToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RouteItem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 建议远端下发路由表差异部分，用远端包覆盖本地更合理&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;RouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addRouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 在异步执行TheRouter内部兜底路由表&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;initRouteMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.5 高级用法&lt;/h4&gt;

&lt;p&gt;TheRouter同时支持更多页面跳转能力，详情可参考项目文档【&lt;a href=&quot;https://therouter.cn/docs/2022/08/28/01&quot;&gt;https://therouter.cn/docs/2022/08/28/01&lt;/a&gt;】：    &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;为第三方库里面的页面添加路由表，达到对某些页面降级替换的目的；&lt;br&gt;&lt;/li&gt;
&lt;li&gt;延迟路由跳转（从Android 8开始，不能在后台启动页面）；&lt;br&gt;&lt;/li&gt;
&lt;li&gt;跳转过程拦截器（总共四层，可根据实际需求使用）；&lt;br&gt;&lt;/li&gt;
&lt;li&gt;跳转结果回调；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;四、跨模块依赖注入 ServiceProvider 的设计&lt;/h3&gt;

&lt;p&gt;对于模块化开发中跨模块的调用，我们推荐采用 &lt;a href=&quot;https://zh.m.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&quot;&gt;SOA(面向服务架构)&lt;/a&gt; 的设计方式，服务调用方与使用方完全隔离，调用模块外的能力不需要关注能力的提供者是谁。&lt;br&gt;
&lt;code&gt;ServiceProvider&lt;/code&gt; 的核心设计思想也是这样的，目前服务间的调用协议采用接口的方式。当然，也可以兼容不通过接口下沉而是直接调用的情况。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dbabea09faa4a598faf46ffd7462de9~tplv-k3u1fbpfcp-watermark.image?&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体到 Android 侧就是 AIDL 类似的设计，只是要比AIDL开发简单很多：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务提供方负责提供服务，不需要关心调用方是谁会在何时调用自己。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;服务的使用方只关注服务本身，不需要关心这个服务是谁提供的，只需要只能服务能提供哪些能力即可。&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如上面的图片：拉拉需要使用录音的服务，小货则向外提供一个录音的服务，由&lt;code&gt;TheRouter&lt;/code&gt;的&lt;code&gt;ServiceProvider&lt;/code&gt;负责撮合。  &lt;/p&gt;

&lt;h4&gt;4.1 服务使用方：拉拉&lt;/h4&gt;

&lt;p&gt;她无需关心，&lt;code&gt;IRecordService&lt;/code&gt;这个接口服务是谁提供的，他只需要知道自己需要使用这样的一个服务就行了。&lt;br&gt;
注：如果没有提供服务的提供方，&lt;code&gt;TheRouter.get()&lt;/code&gt;可能返回&lt;code&gt;null&lt;/code&gt;  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;IRecordService:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)?.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;doRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2 服务提供方：小货&lt;/h4&gt;

&lt;p&gt;服务提供方需要声明一个提供服务的方法，用&lt;code&gt;@ServiceProvider&lt;/code&gt;注解标记。  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果是 &lt;code&gt;java&lt;/code&gt;，必须是 &lt;code&gt;public static&lt;/code&gt; 修饰&lt;/li&gt;
&lt;li&gt;如果是 &lt;code&gt;kotlin&lt;/code&gt;，建议写成 top level 的函数&lt;/li&gt;
&lt;li&gt;方法名不限&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 方法名不限定，任意名字都行
 * 返回值必须是服务接口名，如果是实现了服务的子类，需要加上returnType限定（例如下面代码）
 * 方法必须加上 public static 修饰，否则编译期就会报错
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ServiceProvider&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRecordService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;IRecordService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;doRecord&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;执行录制逻辑&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 也可以直接返回对象，然后标注这个方法的服名是什么&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ServiceProvider&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRecordService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RecordServiceImpl&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// xxx &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、单模块自动初始化能力 FlowTaskExecutor 的设计&lt;/h3&gt;

&lt;p&gt;前面讲过，&lt;code&gt;TheRouter&lt;/code&gt;是完全面向模块化开发提供的一套解决方案。在模块化开发时，可能每个模块都有自己需要初始化的一些代码。以前的做法是把这些代码都在&lt;code&gt;Application&lt;/code&gt;里声明，但是这样可能随着业务变动每次都需要修改&lt;code&gt;Application&lt;/code&gt;所在模块。&lt;code&gt;TheRouter&lt;/code&gt; 的单模块自动初始化能力就是为了解决这样的情况，可以只在当前模块声明初始化方法后，将会在业务场景时自动被调用。    &lt;/p&gt;

&lt;p&gt;每个希望被自动初始化的方法，必须使用&lt;code&gt;public static&lt;/code&gt;修饰，主要原因是这样子就能通过类名直接调用了。另外很多初始化代码都需要获取&lt;code&gt;Context&lt;/code&gt;对象，所以我们将&lt;code&gt;Context&lt;/code&gt;作为初始化方法的默认参数，会自动传入&lt;code&gt;Application&lt;/code&gt;。其他的所在类名、方法名都没有限制，反正只要加上了 &lt;code&gt;@FlowTask&lt;/code&gt; 注解，在编译期都能通过 APT 获取到。   &lt;/p&gt;

&lt;h4&gt;5.1 FlowTaskExecutor 使用介绍&lt;/h4&gt;

&lt;p&gt;可以在当前模块中，任意类中声明一个任意方法名的方法，给方法添加上&lt;code&gt;@FlowTask&lt;/code&gt; 的注解即可。   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;@FlowTask&lt;/code&gt; 注解参数说明： &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;taskName&lt;/strong&gt;：当前初始化任务的任务名，必须全局唯一，建议格式为：&lt;code&gt;moduleName_taskName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dependsOn&lt;/strong&gt;：参考&lt;code&gt;Gradle&lt;/code&gt; Task，任务与任务之间可能会有依赖关系。如果当前任务需要依赖其他任务先初始化，则在这里声明依赖的任务名。可以同时依赖多个任务，用英文逗号分隔，空格可选，会被过滤：dependsOn = &amp;quot;mmkv, config, login&amp;quot;，默认为空，应用启动就被调用。注：&lt;code&gt;dependsOn&lt;/code&gt;只能保证&lt;code&gt;task&lt;/code&gt;是在依赖任务之后执行，由于内部逻辑都是在异步线程操作，取决于线程切换，并不一定是立刻执行。&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;async&lt;/strong&gt;：是否要在异步执行此任务，默认false。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 将会在异步执行
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@FlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taskName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mmkv_init&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependsOn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TheRouterFlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;APP_ONCREATE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;异步=========Application onCreate后执行&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@FlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taskName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;app1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main线程=========应用启动就会执行&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/**
 * 将会在主线程初始化
 */&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@FlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taskName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dependsOn&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;mmkv,app1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main线程=========在app1和mmkv两个任务都执行以后才会被执行&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.2内置初始化节点&lt;/h4&gt;

&lt;p&gt;使用这个能力，在路由内部默认支持了两个生命周期类任务，可在使用时直接引用  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; &lt;strong&gt;TheRouterFlowTask.APP_ONCREATE&lt;/strong&gt;：当Application的onCreate()执行后初始化&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TheRouterFlowTask.APP_ONSPLASH&lt;/strong&gt;：当应用的首个Activity.onCreate()执行后初始化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TheRouterFlowTask. BEFORE_THEROUTER _INITIALIZATION&lt;/strong&gt;：当应用启动后，在TheRouter初始化之前，执行任务。(1.1.1-rc2版本新增)&lt;br&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同时，使用&lt;code&gt;TheRouter&lt;/code&gt;的自动初始化依赖，也无需担心循环依赖造成的问题，框架会在编译期构建有向无环图，监测循环依赖情况，如果发现会在编译期直接报错，并且还会将发生循环引用的任务显示出来，用于排错。   &lt;/p&gt;

&lt;h4&gt;5.3  实现原理&lt;/h4&gt;

&lt;p&gt;每个加了 &lt;code&gt;@FlowTask&lt;/code&gt; 注解的方法，都会在编译期被解析，生成一个对应的 &lt;code&gt;Task&lt;/code&gt; 对象，这个对象包含了初始化方法的相关信息，比如：是否异步执行、任务名、是否依赖其他任务先执行。   &lt;/p&gt;

&lt;p&gt;当所有aar都编译完成，生成好全部的 &lt;code&gt;Task&lt;/code&gt; 以后，会在主 app 中通过&lt;code&gt;Gradle&lt;/code&gt;插件进行聚合，在这时会将所有的 &lt;code&gt;Task&lt;/code&gt; 做一次检查，通过构建&lt;code&gt;有向无环图&lt;/code&gt;来防止 &lt;code&gt;Task&lt;/code&gt; 发生循环引用的情况。  &lt;/p&gt;

&lt;p&gt;每次应用启动后，会在路由初始化时，将有向图中的全部&lt;code&gt;Task&lt;/code&gt;，按照依赖关系按顺序加载。  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b400b35a3c0244479ef61ce6759b25a7~tplv-k3u1fbpfcp-watermark.image?&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;六、动态化能力 ActionManager 的设计&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Action&lt;/code&gt; 本质是一个全局的系统回调，主要用于预埋的一系列操作，例如：弹窗、上传日志、清理缓存。&lt;br&gt;
与 Android 系统自带的广播通知类似，你可以在任何地方声明动作与处理方式。并且所有&lt;code&gt;Action&lt;/code&gt;都是可以被跟踪的，只要你愿意，可以在日志中将所有的动作调用栈输出，以方便调试使用，这样在一定程度上可以解决观察者模式带来的通病：&lt;strong&gt;无法追踪&lt;code&gt;Observable&lt;/code&gt;的问题&lt;/strong&gt;。&lt;/p&gt;

&lt;h4&gt;6.1 Action 使用&lt;/h4&gt;

&lt;p&gt;声明一个 Action：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// action建议遵循一定的格式&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;therouter://action/xxx&quot;&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;@FlowTask&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;taskName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action_demo&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;context:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addActionInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;object:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ActionInterceptor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;context:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;args:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// do something&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行一个 Action：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// action建议遵循一定的格式&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;therouter://action/xxx&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 如果执行了一个没有被声明的Action，则不会有任何动作&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;TheRouter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ACTION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.2 高级用法&lt;/h4&gt;

&lt;p&gt;每个&lt;code&gt;Action&lt;/code&gt; 允许关联多个 &lt;code&gt;ActionInterceptor&lt;/code&gt;进行处理，多个&lt;code&gt;ActionInterceptor&lt;/code&gt;之间可以自定义拦截器优先级，同时允许终止接下来的低优先级拦截器的执行。   &lt;/p&gt;

&lt;p&gt;最典型应用场景：首页可能会有多个弹窗，不同业务之间的弹窗是有优先级之分的，为了体验优化我们肯定不会在首页一次把所有弹窗全部弹出，可以通过&lt;code&gt;ActionInterceptor&lt;/code&gt;为每个弹窗声明好优先级关系，假设需求是首页只能弹出3个弹窗，那么第三个弹窗处理完毕即可关闭当前事件，接下来的拦截器将不会被响应。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ActionInterceptor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;context:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;args:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Boolean&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onFinish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/**
     * 数字越大，优先级越高
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;open&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;priority:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;6.3 客户端动态响应使用场景&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;如果仅客户端使用&lt;/strong&gt;，常用的场景可能是：当用户执行某些操作（打开某个页面、H5点击某个按钮、动态页面配置的点击事件）时，将会自动触发，执行预埋的 Action 逻辑。   &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果与服务端链路打通&lt;/strong&gt;，这个能力其实是需要整个公司的配合，比如有一套类似智慧大脑的方案，可以基于客户端过去的一些埋点数据，智能推断出用户下一步要做的事情，然后通过长连接直接向客户端下发指令做某些事情。那么通过客户端预埋的页面跳转、弹窗、清缓存、退出登录等等操作，就可以通过服务端指令进行操作，则就是一套完整的动态化方案。   &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bae49fec9d94ae2a3cdf2d07b39efa6~tplv-k3u1fbpfcp-zoom-1.image&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;七、一键切换源码与 AAR&lt;/h3&gt;

&lt;h4&gt;7.1 模块化支持的 Gradle 脚本&lt;/h4&gt;

&lt;p&gt;在模块化开发过程中，如果没有采用分仓，或采用了分仓但依然使用 &lt;code&gt;git-submodule&lt;/code&gt; 的方式开发，应该都会遇到一个问题。如果集成包采用源码编译，构建时间实在太久，大大降低开发调试效率；如果采用aar依赖编译，对于底层模块修改了代码，每次都要重新构建aar，在上层模块修改版本号以后，才能继续整包构建编译，也极大影响开发效率。&lt;br&gt;
&lt;code&gt;TheRouter&lt;/code&gt; 中提供了一个 &lt;code&gt;Gradle&lt;/code&gt; 脚本，只需要在开发本地的&lt;code&gt;local.properties&lt;/code&gt;文件中声明要参与编译的&lt;code&gt;module&lt;/code&gt;，其他未声明的默认使用aar编译，这样就能灵活切换源码与aar，并且不会影响其他人，如下节选代码可供参考使用：  &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * 如果工程中有源码，则依赖源码，否则依赖aar
 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;moduleApi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compileStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Closure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configureClosure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compileStr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;:&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;artifactid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;includeModule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HashSet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rootProject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getAllprojects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rootProject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;includeModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;includeModule&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;artifactid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;源码依赖：===project(\&quot;:$artifactid\&quot;)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;projects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;api&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;':'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;artifactid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configureClosure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//        projects.project.configurations { compile.exclude group: group, module: artifactid }&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;依赖：=======$group:$artifactid:$version&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;projects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;api&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$group:$artifactid:$version&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;configureClosure&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际使用时，可以完全使用&lt;code&gt;moduleApi&lt;/code&gt; 替换掉原有的&lt;code&gt;api&lt;/code&gt;。当然， &lt;code&gt;implementation&lt;/code&gt;也可以有一个对应的&lt;code&gt;moduleImplementation&lt;/code&gt;，这样只需要注释或解注释&lt;code&gt;setting.gradle&lt;/code&gt;文件内的&lt;code&gt;include&lt;/code&gt;语句就可以达到切换源码、&lt;code&gt;aar&lt;/code&gt;的目的了。&lt;/p&gt;

&lt;h3&gt;八、从其他路由迁移至 TheRouter&lt;/h3&gt;

&lt;h4&gt;8.1 迁移工具一键迁移&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt;提供了图形化界面的迁移工具，可以一键从其他路由迁移到&lt;code&gt;TheRouter&lt;/code&gt;，目前仅支持&lt;code&gt;ARouter&lt;/code&gt;，其他路由框架迁移也在开发中（GitHub下载，70M左右，请耐心等待）：  &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mac OS 迁移工具下载：&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Mac.zip&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Mac.zip&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;Windows 迁移工具下载：&lt;a href=&quot;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Windows.zip&quot;&gt;https://github.com/HuolalaTech/hll-wp-therouter-android/wiki/uploads/file/TheRouterTransfer-Windows.zip&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果项目中使用了ARouter的IProvider.init()方法，可能需要手动处理初始化逻辑。&lt;br&gt;
如下图：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f2cc2b3509f41ccaa11dc9617088033~tplv-k3u1fbpfcp-watermark.image?&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;8.2 与其他路由对比&lt;/h4&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;TheRouter&lt;/th&gt;
&lt;th&gt;ARouter&lt;/th&gt;
&lt;th&gt;WMRouter&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Fragment路由&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持依赖注入&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;加载路由表&lt;/td&gt;
&lt;td&gt;无运行时扫描&lt;br&gt;无反射&lt;/td&gt;
&lt;td&gt;运行时扫描dex(新版本改为反射)&lt;br&gt;反射实例类&lt;br&gt;性能损耗大&lt;/td&gt;
&lt;td&gt;运行时读文件&lt;br&gt;反射实例类&lt;br&gt;性能损耗中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;注解正则表达式&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Activity指定拦截器&lt;/td&gt;
&lt;td&gt;✔️（四大拦截器可根据业务定制）&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;导出路由文档&lt;/td&gt;
&lt;td&gt;✔️（路由文档支持添加注释描述）&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动态注册路由信息&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;APT支持增量编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️（开启文档生成则无法增量编译）&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;plugin支持增量编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持KSP编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持 AGP8 编译&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;Gradle7.3以后无法使用&lt;/td&gt;
&lt;td&gt;Gradle7.3以后无法使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;多 Path 对应同一页面（低成本实现双端path统一）&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;远端路由表下发&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持单模块独立初始化&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持使用路由打开第三方SDK页面&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;td&gt;✖️&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;对热修复支持（例如tinker）&lt;/td&gt;
&lt;td&gt;✔️(未改变的代码多次构建无变动)&lt;/td&gt;
&lt;td&gt;✖️(多次构建apt产物会发生变化，生成无意义补丁)&lt;/td&gt;
&lt;td&gt;✖️(多次构建apt产物会发生变化，生成无意义补丁)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;九、总结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;TheRouter&lt;/code&gt; 并不仅仅是一个小巧灵活的路由库，而是一整套完整的 &lt;code&gt;Android&lt;/code&gt; 模块化解决方案，能够解决几乎全部的模块化过程中会遇到的问题。&lt;br&gt;
对于现有的路由框架，我们也在最大限度支持平滑迁移，目前已完成&lt;code&gt;ARouter&lt;/code&gt;的一键迁移工具，其他框架的迁移仍在开发中。你也可以在&lt;code&gt;Github&lt;/code&gt; &lt;code&gt;issue&lt;/code&gt;中提出需求，我们评估后会尽快支持，也欢迎任何人提供 &lt;code&gt;Pull Requests&lt;/code&gt;。  &lt;/p&gt;

&lt;p&gt;更多问题请加群沟通：&lt;br&gt;
&lt;img src=&quot;https://kymjs.com/therouter/wx/therouter_wx.jpg&quot; class=&quot;blog-img&quot;/&gt;&lt;/p&gt;</content><author><name></name></author><category term="news" /><summary type="html">TheRouter 是一个 Kotlin 编写，用于 Android 模块化开发的一整套解决方案框架。 Github 项目地址与使用文档详见 https://github.com/HuolalaTech/hll-wp-therouter-android。</summary></entry></feed>